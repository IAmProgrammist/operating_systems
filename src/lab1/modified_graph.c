#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>

int main()
{
    int status = 0;
    /*
    Получаем PID текущего процесса, корня дерева и выводим его. Дерево:

    0

    */
    printf("Мы начали в корне 0! Тут pid = %d.\n", getpid());

    /*
    Создаём левый элемент для корня 0, создаём процесс.
    Если node_1 == 0, значит мы находимся в дочернем листе.
    Иначе смотреть ниже для создания правого элемента для корня
    дерева.
    */
    pid_t node_1 = fork();
    if (node_1 == 0)
    {
        /*
        Получаем PID текущего процесса-поддерева и PID родительского элемента PPID. Дерево:

          0
         / \
        1  ...

        */
        printf("Мы в поддереве 1! Тут pid = %d, ppid = %d.\n", getpid(), getppid());

        // Аналогично создзаём левый элемент для поддерева 1.
        // если это дочерний процесс - это лист, выполняем работу.
        pid_t node_3 = fork();
        if (node_3 == 0)
        {
            /*
            Получаем PID текущего процесса-поддерева и PID родительского элемента PPID. Дерево:

                0
               / \
              1  ...
             / \
            3  ...
            */
            printf("Мы в листе 3! Тут pid = %d, ppid = %d.\nКажется, этот лист собирается расти!\n", getpid(), getppid());

            // Аналогично создаём дочерние листья для поддерева 3
            pid_t node_7 = fork();
            if (node_7 == 0)
            {
                /*
                Получаем PID текущего процесса-поддерева и PID родительского элемента PPID. Дерево:

                      0
                     / \
                    1  ...
                   / \
                  3  ...
                 / \ 
                7  ...

                Выполняем работу и выходим с кодом 0
                */
                printf("Мы в свежем листе 7! Тут pid = %d, ppid = %d.\n", getpid(), getppid());
                sleep(30);
                exit(0);
            }
            pid_t node_8 = fork();
            if (node_8 == 0)
            {
                /*
                Получаем PID текущего процесса-поддерева и PID родительского элемента PPID. Дерево:

                       0
                      / \
                     1  ...
                    / \
                   3  ...
                  / \ 
                ...  8

                Выполняем работу и выходим с кодом 0
                */
                printf("Мы в свежем листе 8! Тут pid = %d, ppid = %d.\n", getpid(), getppid());
                sleep(30);
                exit(0);
            }
            
            // Мы находимся в родительском поддереве и ожидаем, когда закончат работу листья.
            // если листья закончились с ошибкой, выходим из процесса с ошибкой
            printf("Ожидаем окончания листа 7 с pid = %d.\n", node_7);
            waitpid(node_7, &status, 0);
            if (status)
            {
                printf("Лист 7 завершился с ошибкой!\n");
                exit(status);
            }

            printf("Ожидаем окончания листа 8 с pid = %d.\n", node_8);
            waitpid(node_8, &status, 0);
            if (status)
            {
                printf("Лист 8 завершился с ошибкой!\n");
                exit(status);
            }

            // Листы выполнились корректно, возвращаем 0.
            exit(0);
        }

        // Аналогично создзаём правый элемент для поддерева 1.
        // если это дочерний процесс - это лист, выполняем работу.
        pid_t node_4 = fork();
        if (node_4 == 0)
        {
            /*
            Получаем PID текущего процесса-поддерева и PID родительского элемента PPID. Дерево:

                 0
                / \
               1  ...
              / \
            ...  4
            */
            printf("Мы в листе 4! Тут pid = %d, ppid = %d.\n", getpid(), getppid());
            // Выполняем работу
            sleep(30);
            // И выходим из процесса
            exit(0);
        }
        
        // Ожидаем, когда закончат выполнение листы поддерева и если в них возникает ошибка
        // возвращаем ошибку
        printf("Ожидаем окончания листа 3 с pid = %d.\n", node_3);
        waitpid(node_3, &status, 0);
        if (status)
        {
            printf("Лист 3 завершился с ошибкой!\n");
            exit(status);
        }

        printf("Ожидаем окончания листа 4 с pid = %d.\n", node_4);
        waitpid(node_4, &status, 0);
        if (status)
        {
            printf("Лист 4 завершился с ошибкой!\n");
            exit(status);
        }

        // Листы выполнились корректно, возвращаем 0.
        exit(0);
    }

    /*
    Создаём правый элемент для корня 0, создаём процесс.
    Если node_2 == 0, значит мы находимся в дочернем листе.
    Иначе смотреть ниже для ожидания окончания выполнения элементов
    дерева
    */
    pid_t node_2 = fork();
    if (node_2 == 0)
    {
        /*
        Получаем PID текущего процесса-поддерева и PID родительского элемента PPID. Дерево:

           0
          / \
        ...  2

        */
        printf("Мы в поддереве 2! Тут pid = %d, ppid = %d.\n", getpid(), getppid());

        // Аналогично создзаём левый элемент для поддерева 2.
        // если это дочерний процесс - это лист, выполняем работу.
        pid_t node_5 = fork();
        if (node_5 == 0)
        {
            /*
            Получаем PID текущего процесса-поддерева и PID родительского элемента PPID. Дерево:

               0
              / \
            ...  2
                / \
               5  ...
            */
            printf("Мы в листе 5! Тут pid = %d, ppid = %d.\n", getpid(), getppid());
            // Выполняем работу
            sleep(30);
            // И выходим из процесса
            exit(0);
        }

        // Иначе - создаём новый лист. Если это дочерний процесс - это лист
        // и выполняем работу
        pid_t node_6 = fork();
        if (node_6 == 0)
        {
            /*
            Получаем PID текущего процесса-поддерева и PID родительского элемента PPID. Дерево:

               0
              / \
            ...  2
                / \
              ...  6
            */
            printf("Мы в листе 6! Тут pid = %d, ppid = %d.\n", getpid(), getppid());
            // Выполняем работу
            sleep(30);
            // И выходим из процесса
            exit(0);
        }

        // Ожидаем, когда закончат выполнение листы поддерева и если в них возникает ошибка
        // возвращаем ошибку
        printf("Ожидаем окончания листа 5 с pid = %d.\n", node_5);
        waitpid(node_5, &status, 0);
        if (status)
        {
            printf("Лист 5 завершился с ошибкой!\n");
            exit(status);
        }

        printf("Ожидаем окончания листа 6 с pid = %d.\n", node_6);
        waitpid(node_6, &status, 0);
        if (status)
        {
            printf("Лист 6 завершился с ошибкой!\n");
            exit(status);
        }

        // Листы выполнились корректно, возвращаем 0.
        exit(0);
    }

    /*
    Ожидаем, пока левый элемент node_1 выполняет свою работу. Если
    он выполняется с ошибкой, возвращаем эту ошибку.
    */
    printf("Ожидаем окончания поддерева 1 с pid = %d.\n", node_1);
    waitpid(node_1, &status, 0);
    if (status)
    {
        printf("Поддерево 1 завершилось с ошибкой!\n");
        exit(status);
    }

    /*
    Ожидаем, пока правый элемент node_2 выполняет свою работу. Если
    он выполняется с ошибкой, возвращаем эту ошибку.
    */
    printf("Ожидаем окончания поддерева 2 с pid = %d.\n", node_2);
    waitpid(node_2, &status, 0);
    if (status)
    {
        printf("Поддерево 2 завершилось с ошибкой!\n");
        exit(status);
    }

    /*
    Все процессы-поддеревья выполнены корректно, возвращаем 0.
    */
    return 0;
}